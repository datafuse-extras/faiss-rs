/* automatically generated by rust-bindgen 0.65.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const FAISS_IO_FLAG_MMAP: u32 = 1;
pub const FAISS_IO_FLAG_READ_ONLY: u32 = 2;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type faiss_idx_t = i64;
pub type idx_t = faiss_idx_t;
pub type faiss_component_t = f32;
pub type faiss_distance_t = f32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissRangeSearchResult_H {
    _unused: [u8; 0],
}
pub type FaissRangeSearchResult = FaissRangeSearchResult_H;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelector_H {
    _unused: [u8; 0],
}
pub type FaissIDSelector = FaissIDSelector_H;
#[doc = "< maximum inner product search"]
pub const FaissMetricType_METRIC_INNER_PRODUCT: FaissMetricType = 0;
#[doc = "< squared L2 search"]
pub const FaissMetricType_METRIC_L2: FaissMetricType = 1;
#[doc = "< L1 (aka cityblock)"]
pub const FaissMetricType_METRIC_L1: FaissMetricType = 2;
#[doc = "< infinity distance"]
pub const FaissMetricType_METRIC_Linf: FaissMetricType = 3;
#[doc = "< L_p distance, p is given by metric_arg"]
pub const FaissMetricType_METRIC_Lp: FaissMetricType = 4;
#[doc = " some additional metrics defined in scipy.spatial.distance"]
pub const FaissMetricType_METRIC_Canberra: FaissMetricType = 20;
#[doc = " some additional metrics defined in scipy.spatial.distance"]
pub const FaissMetricType_METRIC_BrayCurtis: FaissMetricType = 21;
#[doc = " some additional metrics defined in scipy.spatial.distance"]
pub const FaissMetricType_METRIC_JensenShannon: FaissMetricType = 22;
#[doc = " Some algorithms support both an inner product version and a L2 search\n version."]
pub type FaissMetricType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIndex_H {
    _unused: [u8; 0],
}
pub type FaissIndex = FaissIndex_H;
extern "C" {
    pub fn faiss_Index_free(obj: *mut FaissIndex);
}
extern "C" {
    pub fn faiss_Index_d(arg1: *const FaissIndex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Index_is_trained(arg1: *const FaissIndex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Index_ntotal(arg1: *const FaissIndex) -> idx_t;
}
extern "C" {
    pub fn faiss_Index_metric_type(arg1: *const FaissIndex) -> FaissMetricType;
}
extern "C" {
    pub fn faiss_Index_verbose(arg1: *const FaissIndex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Index_set_verbose(arg1: *mut FaissIndex, arg2: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Perform training on a representative set of vectors\n\n @param index  opaque pointer to index object\n @param n      nb of training vectors\n @param x      training vectors, size n * d"]
    pub fn faiss_Index_train(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add n vectors of dimension d to the index.\n\n Vectors are implicitly assigned labels ntotal .. ntotal + n - 1\n This function slices the input vectors in chunks smaller than\n blocksize_add and calls add_core.\n @param index  opaque pointer to index object\n @param x      input matrix, size n * d"]
    pub fn faiss_Index_add(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as add, but stores xids instead of sequential ids.\n\n The default implementation fails with an assertion, as it is\n not supported by all indexes.\n\n @param index  opaque pointer to index object\n @param xids   if non-null, ids to store for the vectors (size n)"]
    pub fn faiss_Index_add_with_ids(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
        xids: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " query n vectors of dimension d to the index.\n\n return at most k vectors. If there are not enough results for a\n query, the result array is padded with -1s.\n\n @param index       opaque pointer to index object\n @param x           input vectors to search, size n * d\n @param labels      output labels of the NNs, size n*k\n @param distances   output pairwise distances, size n*k"]
    pub fn faiss_Index_search(
        index: *const FaissIndex,
        n: idx_t,
        x: *const f32,
        k: idx_t,
        distances: *mut f32,
        labels: *mut idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " query n vectors of dimension d to the index.\n\n return all vectors with distance < radius. Note that many\n indexes do not implement the range_search (only the k-NN search\n is mandatory).\n\n @param index       opaque pointer to index object\n @param x           input vectors to search, size n * d\n @param radius      search radius\n @param result      result table"]
    pub fn faiss_Index_range_search(
        index: *const FaissIndex,
        n: idx_t,
        x: *const f32,
        radius: f32,
        result: *mut FaissRangeSearchResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " return the indexes of the k vectors closest to the query x.\n\n This function is identical as search but only return labels of neighbors.\n @param index       opaque pointer to index object\n @param x           input vectors to search, size n * d\n @param labels      output labels of the NNs, size n*k"]
    pub fn faiss_Index_assign(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
        labels: *mut idx_t,
        k: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " removes all elements from the database.\n @param index       opaque pointer to index object"]
    pub fn faiss_Index_reset(index: *mut FaissIndex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " removes IDs from the index. Not supported by all indexes\n @param index       opaque pointer to index object\n @param nremove     output for the number of IDs removed"]
    pub fn faiss_Index_remove_ids(
        index: *mut FaissIndex,
        sel: *const FaissIDSelector,
        n_removed: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reconstruct a stored vector (or an approximation if lossy coding)\n\n this function may not be defined for some indexes\n @param index       opaque pointer to index object\n @param key         id of the vector to reconstruct\n @param recons      reconstructed vector (size d)"]
    pub fn faiss_Index_reconstruct(
        index: *const FaissIndex,
        key: idx_t,
        recons: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reconstruct vectors i0 to i0 + ni - 1\n\n this function may not be defined for some indexes\n @param index       opaque pointer to index object\n @param recons      reconstructed vector (size ni * d)"]
    pub fn faiss_Index_reconstruct_n(
        index: *const FaissIndex,
        i0: idx_t,
        ni: idx_t,
        recons: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes a residual vector after indexing encoding.\n\n The residual vector is the difference between a vector and the\n reconstruction that can be decoded from its representation in\n the index. The residual can be used for multiple-stage indexing\n methods, like IndexIVF's methods.\n\n @param index       opaque pointer to index object\n @param x           input vector, size d\n @param residual    output residual vector, size d\n @param key         encoded index, as returned by search and assign"]
    pub fn faiss_Index_compute_residual(
        index: *const FaissIndex,
        x: *const f32,
        residual: *mut f32,
        key: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes a residual vector after indexing encoding.\n\n The residual vector is the difference between a vector and the\n reconstruction that can be decoded from its representation in\n the index. The residual can be used for multiple-stage indexing\n methods, like IndexIVF's methods.\n\n @param index       opaque pointer to index object\n @param n           number of vectors\n @param x           input vector, size (n x d)\n @param residuals    output residual vectors, size (n x d)\n @param keys         encoded index, as returned by search and assign"]
    pub fn faiss_Index_compute_residual_n(
        index: *const FaissIndex,
        n: idx_t,
        x: *const f32,
        residuals: *mut f32,
        keys: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissParameterRange_H {
    _unused: [u8; 0],
}
pub type FaissParameterRange = FaissParameterRange_H;
extern "C" {
    pub fn faiss_ParameterRange_name(
        arg1: *const FaissParameterRange,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Getter for the values in the range. The output values are invalidated\n upon any other modification of the range."]
    pub fn faiss_ParameterRange_values(
        arg1: *mut FaissParameterRange,
        arg2: *mut *mut f64,
        arg3: *mut usize,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissParameterSpace_H {
    _unused: [u8; 0],
}
pub type FaissParameterSpace = FaissParameterSpace_H;
extern "C" {
    pub fn faiss_ParameterSpace_free(obj: *mut FaissParameterSpace);
}
extern "C" {
    #[doc = " Parameter space default constructor"]
    pub fn faiss_ParameterSpace_new(space: *mut *mut FaissParameterSpace) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " nb of combinations, = product of values sizes"]
    pub fn faiss_ParameterSpace_n_combinations(arg1: *const FaissParameterSpace) -> usize;
}
extern "C" {
    #[doc = " get string representation of the combination\n by writing it to the given character buffer.\n A buffer size of 1000 ensures that the full name is collected."]
    pub fn faiss_ParameterSpace_combination_name(
        arg1: *const FaissParameterSpace,
        arg2: usize,
        arg3: *mut ::std::os::raw::c_char,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set a combination of parameters described by a string"]
    pub fn faiss_ParameterSpace_set_index_parameters(
        arg1: *const FaissParameterSpace,
        arg2: *mut FaissIndex,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set a combination of parameters on an index"]
    pub fn faiss_ParameterSpace_set_index_parameters_cno(
        arg1: *const FaissParameterSpace,
        arg2: *mut FaissIndex,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set one of the parameters"]
    pub fn faiss_ParameterSpace_set_index_parameter(
        arg1: *const FaissParameterSpace,
        arg2: *mut FaissIndex,
        arg3: *const ::std::os::raw::c_char,
        arg4: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " print a description on stdout"]
    pub fn faiss_ParameterSpace_display(arg1: *const FaissParameterSpace);
}
extern "C" {
    #[doc = " add a new parameter (or return it if it exists)"]
    pub fn faiss_ParameterSpace_add_range(
        arg1: *mut FaissParameterSpace,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut FaissParameterRange,
    ) -> ::std::os::raw::c_int;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = [u64; 27usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clone an index. This is equivalent to `faiss::clone_index`"]
    pub fn faiss_clone_index(
        arg1: *const FaissIndex,
        p_out: *mut *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Class for the clustering parameters. Can be passed to the\n constructor of the Clustering object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissClusteringParameters {
    #[doc = "< clustering iterations"]
    pub niter: ::std::os::raw::c_int,
    #[doc = "< redo clustering this many times and keep best"]
    pub nredo: ::std::os::raw::c_int,
    #[doc = "< (bool)"]
    pub verbose: ::std::os::raw::c_int,
    #[doc = "< (bool) do we want normalized centroids?"]
    pub spherical: ::std::os::raw::c_int,
    #[doc = "< (bool) round centroids coordinates to integer"]
    pub int_centroids: ::std::os::raw::c_int,
    #[doc = "< (bool) update index after each iteration?"]
    pub update_index: ::std::os::raw::c_int,
    #[doc = "< (bool) use the centroids provided as input and do\n< not change them during iterations"]
    pub frozen_centroids: ::std::os::raw::c_int,
    #[doc = "< otherwise you get a warning"]
    pub min_points_per_centroid: ::std::os::raw::c_int,
    #[doc = "< to limit size of dataset"]
    pub max_points_per_centroid: ::std::os::raw::c_int,
    #[doc = "< seed for the random number generator"]
    pub seed: ::std::os::raw::c_int,
    #[doc = "< how many vectors at a time to decode"]
    pub decode_block_size: usize,
}
#[test]
fn bindgen_test_layout_FaissClusteringParameters() {
    const UNINIT: ::std::mem::MaybeUninit<FaissClusteringParameters> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FaissClusteringParameters>(),
        48usize,
        concat!("Size of: ", stringify!(FaissClusteringParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<FaissClusteringParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(FaissClusteringParameters))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).niter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(niter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nredo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(nredo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verbose) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(verbose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spherical) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(spherical)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_centroids) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(int_centroids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_index) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(update_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frozen_centroids) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(frozen_centroids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_points_per_centroid) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(min_points_per_centroid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_points_per_centroid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(max_points_per_centroid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seed) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(seed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decode_block_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(decode_block_size)
        )
    );
}
extern "C" {
    #[doc = " Sets the ClusteringParameters object with reasonable defaults"]
    pub fn faiss_ClusteringParameters_init(params: *mut FaissClusteringParameters);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissClustering_H {
    _unused: [u8; 0],
}
pub type FaissClustering = FaissClustering_H;
extern "C" {
    pub fn faiss_Clustering_niter(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_nredo(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_verbose(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_spherical(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_int_centroids(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_update_index(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_frozen_centroids(arg1: *const FaissClustering)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_min_points_per_centroid(
        arg1: *const FaissClustering,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_max_points_per_centroid(
        arg1: *const FaissClustering,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_seed(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_decode_block_size(arg1: *const FaissClustering) -> usize;
}
extern "C" {
    pub fn faiss_Clustering_d(arg1: *const FaissClustering) -> usize;
}
extern "C" {
    pub fn faiss_Clustering_k(arg1: *const FaissClustering) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissClusteringIterationStats_H {
    _unused: [u8; 0],
}
pub type FaissClusteringIterationStats = FaissClusteringIterationStats_H;
extern "C" {
    pub fn faiss_ClusteringIterationStats_obj(arg1: *const FaissClusteringIterationStats) -> f32;
}
extern "C" {
    pub fn faiss_ClusteringIterationStats_time(arg1: *const FaissClusteringIterationStats) -> f64;
}
extern "C" {
    pub fn faiss_ClusteringIterationStats_time_search(
        arg1: *const FaissClusteringIterationStats,
    ) -> f64;
}
extern "C" {
    pub fn faiss_ClusteringIterationStats_imbalance_factor(
        arg1: *const FaissClusteringIterationStats,
    ) -> f64;
}
extern "C" {
    pub fn faiss_ClusteringIterationStats_nsplit(
        arg1: *const FaissClusteringIterationStats,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " getter for centroids (size = k * d)"]
    pub fn faiss_Clustering_centroids(
        clustering: *mut FaissClustering,
        centroids: *mut *mut f32,
        size: *mut usize,
    );
}
extern "C" {
    #[doc = " getter for iteration stats"]
    pub fn faiss_Clustering_iteration_stats(
        clustering: *mut FaissClustering,
        iteration_stats: *mut *mut FaissClusteringIterationStats,
        size: *mut usize,
    );
}
extern "C" {
    #[doc = " the only mandatory parameters are k and d"]
    pub fn faiss_Clustering_new(
        p_clustering: *mut *mut FaissClustering,
        d: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_new_with_params(
        p_clustering: *mut *mut FaissClustering,
        d: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        cp: *const FaissClusteringParameters,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_train(
        clustering: *mut FaissClustering,
        n: idx_t,
        x: *const f32,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_free(clustering: *mut FaissClustering);
}
extern "C" {
    #[doc = " simplified interface\n\n @param d dimension of the data\n @param n nb of training vectors\n @param k nb of output centroids\n @param x training set (size n * d)\n @param centroids output centroids (size k * d)\n @param q_error final quantization error\n @return error code"]
    pub fn faiss_kmeans_clustering(
        d: usize,
        n: usize,
        k: usize,
        x: *const f32,
        centroids: *mut f32,
        q_error: *mut f32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " No error"]
pub const FaissErrorCode_OK: FaissErrorCode = 0;
#[doc = " Any exception other than Faiss or standard C++ library exceptions"]
pub const FaissErrorCode_UNKNOWN_EXCEPT: FaissErrorCode = -1;
#[doc = " Faiss library exception"]
pub const FaissErrorCode_FAISS_EXCEPT: FaissErrorCode = -2;
#[doc = " Standard C++ library exception"]
pub const FaissErrorCode_STD_EXCEPT: FaissErrorCode = -4;
#[doc = " An error code which depends on the exception thrown from the previous\n operation. See `faiss_get_last_error` to retrieve the error message."]
pub type FaissErrorCode = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Get the error message of the last failed operation performed by Faiss.\n The given pointer is only invalid until another Faiss function is\n called."]
    pub fn faiss_get_last_error() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn faiss_RangeSearchResult_nq(arg1: *const FaissRangeSearchResult) -> usize;
}
extern "C" {
    pub fn faiss_RangeSearchResult_new(
        p_rsr: *mut *mut FaissRangeSearchResult,
        nq: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchResult_new_with(
        p_rsr: *mut *mut FaissRangeSearchResult,
        nq: idx_t,
        alloc_lims: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " called when lims contains the nb of elements result entries\n for each query"]
    pub fn faiss_RangeSearchResult_do_allocation(
        rsr: *mut FaissRangeSearchResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchResult_free(obj: *mut FaissRangeSearchResult);
}
extern "C" {
    pub fn faiss_RangeSearchResult_buffer_size(arg1: *const FaissRangeSearchResult) -> usize;
}
extern "C" {
    #[doc = " getter for lims: size (nq + 1)"]
    pub fn faiss_RangeSearchResult_lims(rsr: *mut FaissRangeSearchResult, lims: *mut *mut usize);
}
extern "C" {
    #[doc = " getter for labels and respective distances (not sorted):\n result for query i is labels[lims[i]:lims[i+1]]"]
    pub fn faiss_RangeSearchResult_labels(
        rsr: *mut FaissRangeSearchResult,
        labels: *mut *mut idx_t,
        distances: *mut *mut f32,
    );
}
extern "C" {
    pub fn faiss_IDSelector_free(obj: *mut FaissIDSelector);
}
extern "C" {
    #[doc = " Encapsulates a set of ids to remove."]
    pub fn faiss_IDSelector_is_member(
        sel: *const FaissIDSelector,
        id: idx_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelectorRange_H {
    _unused: [u8; 0],
}
pub type FaissIDSelectorRange = FaissIDSelectorRange_H;
extern "C" {
    pub fn faiss_IDSelectorRange_free(obj: *mut FaissIDSelectorRange);
}
extern "C" {
    pub fn faiss_IDSelectorRange_imin(arg1: *const FaissIDSelectorRange) -> idx_t;
}
extern "C" {
    pub fn faiss_IDSelectorRange_imax(arg1: *const FaissIDSelectorRange) -> idx_t;
}
extern "C" {
    #[doc = " remove ids between [imni, imax)"]
    pub fn faiss_IDSelectorRange_new(
        p_sel: *mut *mut FaissIDSelectorRange,
        imin: idx_t,
        imax: idx_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelectorBatch_H {
    _unused: [u8; 0],
}
pub type FaissIDSelectorBatch = FaissIDSelectorBatch_H;
extern "C" {
    pub fn faiss_IDSelectorBatch_nbits(arg1: *const FaissIDSelectorBatch) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IDSelectorBatch_mask(arg1: *const FaissIDSelectorBatch) -> idx_t;
}
extern "C" {
    #[doc = " Remove ids from a set. Repetitions of ids in the indices set\n passed to the constructor does not hurt performance. The hash\n function used for the bloom filter and GCC's implementation of\n unordered_set are just the least significant bits of the id. This\n works fine for random ids or ids in sequences but will produce many\n hash collisions if lsb's are always the same"]
    pub fn faiss_IDSelectorBatch_new(
        p_sel: *mut *mut FaissIDSelectorBatch,
        n: usize,
        indices: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissBufferList_H {
    _unused: [u8; 0],
}
pub type FaissBufferList = FaissBufferList_H;
extern "C" {
    pub fn faiss_BufferList_free(obj: *mut FaissBufferList);
}
extern "C" {
    pub fn faiss_BufferList_buffer_size(arg1: *const FaissBufferList) -> usize;
}
extern "C" {
    pub fn faiss_BufferList_wp(arg1: *const FaissBufferList) -> usize;
}
#[doc = " List of temporary buffers used to store results before they are\n  copied to the RangeSearchResult object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissBuffer {
    pub ids: *mut idx_t,
    pub dis: *mut f32,
}
#[test]
fn bindgen_test_layout_FaissBuffer() {
    const UNINIT: ::std::mem::MaybeUninit<FaissBuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FaissBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(FaissBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<FaissBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(FaissBuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ids) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissBuffer),
            "::",
            stringify!(ids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dis) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissBuffer),
            "::",
            stringify!(dis)
        )
    );
}
extern "C" {
    pub fn faiss_BufferList_append_buffer(bl: *mut FaissBufferList) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_BufferList_new(
        p_bl: *mut *mut FaissBufferList,
        buffer_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_BufferList_add(
        bl: *mut FaissBufferList,
        id: idx_t,
        dis: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " copy elemnts ofs:ofs+n-1 seen as linear data in the buffers to\n tables dest_ids, dest_dis"]
    pub fn faiss_BufferList_copy_range(
        bl: *mut FaissBufferList,
        ofs: usize,
        n: usize,
        dest_ids: *mut idx_t,
        dest_dis: *mut f32,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissRangeSearchPartialResult_H {
    _unused: [u8; 0],
}
pub type FaissRangeSearchPartialResult = FaissRangeSearchPartialResult_H;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissRangeQueryResult_H {
    _unused: [u8; 0],
}
pub type FaissRangeQueryResult = FaissRangeQueryResult_H;
extern "C" {
    pub fn faiss_RangeQueryResult_qno(arg1: *const FaissRangeQueryResult) -> idx_t;
}
extern "C" {
    pub fn faiss_RangeQueryResult_nres(arg1: *const FaissRangeQueryResult) -> usize;
}
extern "C" {
    pub fn faiss_RangeQueryResult_pres(
        arg1: *const FaissRangeQueryResult,
    ) -> *mut FaissRangeSearchPartialResult;
}
extern "C" {
    #[doc = " result structure for a single query"]
    pub fn faiss_RangeQueryResult_add(
        qr: *mut FaissRangeQueryResult,
        dis: f32,
        id: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchPartialResult_res(
        arg1: *const FaissRangeSearchPartialResult,
    ) -> *mut FaissRangeSearchResult;
}
extern "C" {
    pub fn faiss_RangeSearchPartialResult_new(
        p_res: *mut *mut FaissRangeSearchPartialResult,
        res_in: *mut FaissRangeSearchResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchPartialResult_finalize(
        res: *mut FaissRangeSearchPartialResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " called by range_search before do_allocation"]
    pub fn faiss_RangeSearchPartialResult_set_lims(
        res: *mut FaissRangeSearchPartialResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchPartialResult_new_result(
        res: *mut FaissRangeSearchPartialResult,
        qno: idx_t,
        qr: *mut *mut FaissRangeQueryResult,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissDistanceComputer_H {
    _unused: [u8; 0],
}
pub type FaissDistanceComputer = FaissDistanceComputer_H;
extern "C" {
    #[doc = " called before computing distances"]
    pub fn faiss_DistanceComputer_set_query(
        dc: *mut FaissDistanceComputer,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compute distance of vector i to current query.\n This function corresponds to the function call operator:\n DistanceComputer::operator()"]
    pub fn faiss_DistanceComputer_vector_to_query_dis(
        dc: *mut FaissDistanceComputer,
        i: idx_t,
        qd: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " compute distance between two stored vectors"]
    pub fn faiss_DistanceComputer_symmetric_dis(
        dc: *mut FaissDistanceComputer,
        i: idx_t,
        j: idx_t,
        vd: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_DistanceComputer_free(obj: *mut FaissDistanceComputer);
}
extern "C" {
    #[doc = " Build and index with the sequence of processing steps described in\n  the string."]
    pub fn faiss_index_factory(
        p_index: *mut *mut FaissIndex,
        d: ::std::os::raw::c_int,
        description: *const ::std::os::raw::c_char,
        metric: FaissMetricType,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexFlat = FaissIndex_H;
extern "C" {
    #[doc = " Opaque type for IndexFlat"]
    pub fn faiss_IndexFlat_new(p_index: *mut *mut FaissIndexFlat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexFlat_new_with(
        p_index: *mut *mut FaissIndexFlat,
        d: idx_t,
        metric: FaissMetricType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get a pointer to the index's internal data (the `xb` field). The outputs\n become invalid after any data addition or removal operation.\n\n @param index   opaque pointer to index object\n @param p_xb    output, the pointer to the beginning of `xb`.\n @param p_size  output, the current size of `sb` in number of float values."]
    pub fn faiss_IndexFlat_xb(index: *mut FaissIndexFlat, p_xb: *mut *mut f32, p_size: *mut usize);
}
extern "C" {
    pub fn faiss_IndexFlat_cast(arg1: *mut FaissIndex) -> *mut FaissIndexFlat;
}
extern "C" {
    pub fn faiss_IndexFlat_free(obj: *mut FaissIndexFlat);
}
extern "C" {
    #[doc = " compute distance with a subset of vectors\n\n @param index   opaque pointer to index object\n @param x       query vectors, size n * d\n @param labels  indices of the vectors that should be compared\n                for each query vector, size n * k\n @param distances\n                corresponding output distances, size n * k"]
    pub fn faiss_IndexFlat_compute_distance_subset(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
        k: idx_t,
        distances: *mut f32,
        labels: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexFlatIP = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexFlatIP_cast(arg1: *mut FaissIndex) -> *mut FaissIndexFlatIP;
}
extern "C" {
    pub fn faiss_IndexFlatIP_free(obj: *mut FaissIndexFlatIP);
}
extern "C" {
    #[doc = " Opaque type for IndexFlatIP"]
    pub fn faiss_IndexFlatIP_new(p_index: *mut *mut FaissIndexFlatIP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexFlatIP_new_with(
        p_index: *mut *mut FaissIndexFlatIP,
        d: idx_t,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexFlatL2 = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexFlatL2_cast(arg1: *mut FaissIndex) -> *mut FaissIndexFlatL2;
}
extern "C" {
    pub fn faiss_IndexFlatL2_free(obj: *mut FaissIndexFlatL2);
}
extern "C" {
    #[doc = " Opaque type for IndexFlatL2"]
    pub fn faiss_IndexFlatL2_new(p_index: *mut *mut FaissIndexFlatL2) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexFlatL2_new_with(
        p_index: *mut *mut FaissIndexFlatL2,
        d: idx_t,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexRefineFlat = FaissIndex_H;
extern "C" {
    #[doc = " Opaque type for IndexRefineFlat\n\n Index that queries in a base_index (a fast one) and refines the\n results with an exact search, hopefully improving the results."]
    pub fn faiss_IndexRefineFlat_new(
        p_index: *mut *mut FaissIndexRefineFlat,
        base_index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexRefineFlat_free(obj: *mut FaissIndexRefineFlat);
}
extern "C" {
    pub fn faiss_IndexRefineFlat_cast(arg1: *mut FaissIndex) -> *mut FaissIndexRefineFlat;
}
extern "C" {
    pub fn faiss_IndexRefineFlat_own_fields(
        arg1: *const FaissIndexRefineFlat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexRefineFlat_set_own_fields(
        arg1: *mut FaissIndexRefineFlat,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn faiss_IndexRefineFlat_k_factor(arg1: *const FaissIndexRefineFlat) -> f32;
}
extern "C" {
    pub fn faiss_IndexRefineFlat_set_k_factor(arg1: *mut FaissIndexRefineFlat, arg2: f32);
}
pub type FaissIndexFlat1D = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexFlat1D_cast(arg1: *mut FaissIndex) -> *mut FaissIndexFlat1D;
}
extern "C" {
    pub fn faiss_IndexFlat1D_free(obj: *mut FaissIndexFlat1D);
}
extern "C" {
    #[doc = " Opaque type for IndexFlat1D\n\n optimized version for 1D \"vectors\""]
    pub fn faiss_IndexFlat1D_new(p_index: *mut *mut FaissIndexFlat1D) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexFlat1D_new_with(
        p_index: *mut *mut FaissIndexFlat1D,
        continuous_update: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexFlat1D_update_permutation(
        index: *mut FaissIndexFlat1D,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write index to a file.\n This is equivalent to `faiss::write_index` when a file descriptor is\n provided."]
    pub fn faiss_write_index(idx: *const FaissIndex, f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write index to a file.\n This is equivalent to `faiss::write_index` when a file path is provided."]
    pub fn faiss_write_index_fname(
        idx: *const FaissIndex,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read index from a file.\n This is equivalent to `faiss:read_index` when a file descriptor is given."]
    pub fn faiss_read_index(
        f: *mut FILE,
        io_flags: ::std::os::raw::c_int,
        p_out: *mut *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read index from a file.\n This is equivalent to `faiss:read_index` when a file path is given."]
    pub fn faiss_read_index_fname(
        fname: *const ::std::os::raw::c_char,
        io_flags: ::std::os::raw::c_int,
        p_out: *mut *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn serialize_index(
        idx: *const FaissIndex,
        p_out: *mut *mut u8,
        p_size: *mut usize,
        p_capacity: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn deserialize_index(
        data: *const u8,
        size: usize,
        p_out: *mut *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexIVF = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexIVF_free(obj: *mut FaissIndexIVF);
}
extern "C" {
    pub fn faiss_IndexIVF_cast(arg1: *mut FaissIndex) -> *mut FaissIndexIVF;
}
extern "C" {
    pub fn faiss_IndexIVF_nlist(arg1: *const FaissIndexIVF) -> usize;
}
extern "C" {
    pub fn faiss_IndexIVF_nprobe(arg1: *const FaissIndexIVF) -> usize;
}
extern "C" {
    pub fn faiss_IndexIVF_set_nprobe(arg1: *mut FaissIndexIVF, arg2: usize);
}
extern "C" {
    pub fn faiss_IndexIVF_quantizer(arg1: *const FaissIndexIVF) -> *mut FaissIndex;
}
extern "C" {
    pub fn faiss_IndexIVF_quantizer_trains_alone(
        arg1: *const FaissIndexIVF,
    ) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn faiss_IndexIVF_own_fields(arg1: *const FaissIndexIVF) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVF_set_own_fields(arg1: *mut FaissIndexIVF, arg2: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " moves the entries from another dataset to self. On output,\n other is empty. add_id is added to all moved ids (for\n sequential ids, this would be this->ntotal"]
    pub fn faiss_IndexIVF_merge_from(
        index: *mut FaissIndexIVF,
        other: *mut FaissIndexIVF,
        add_id: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " copy a subset of the entries index to the other index\n\n if subset_type == 0: copies ids in [a1, a2)\n if subset_type == 1: copies ids if id % a1 == a2\n if subset_type == 2: copies inverted lists such that a1\n                      elements are left before and a2 elements are after"]
    pub fn faiss_IndexIVF_copy_subset_to(
        index: *const FaissIndexIVF,
        other: *mut FaissIndexIVF,
        subset_type: ::std::os::raw::c_int,
        a1: idx_t,
        a2: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " search a set of vectors, that are pre-quantized by the IVF\n  quantizer. Fill in the corresponding heaps with the query\n  results. search() calls this.\n\n @param n      nb of vectors to query\n @param x      query vectors, size nx * d\n @param assign coarse quantization indices, size nx * nprobe\n @param centroid_dis\n               distances to coarse centroids, size nx * nprobe\n @param distance\n               output distances, size n * k\n @param labels output labels, size n * k\n @param store_pairs store inv list index + inv list offset\n                     instead in upper/lower 32 bit of result,\n                     instead of ids (used for reranking)."]
    pub fn faiss_IndexIVF_search_preassigned(
        index: *const FaissIndexIVF,
        n: idx_t,
        x: *const f32,
        k: idx_t,
        assign: *const idx_t,
        centroid_dis: *const f32,
        distances: *mut f32,
        labels: *mut idx_t,
        store_pairs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVF_get_list_size(index: *const FaissIndexIVF, list_no: usize) -> usize;
}
extern "C" {
    #[doc = " initialize a direct map\n\n @param new_maintain_direct_map    if true, create a direct map,\n                                   else clear it"]
    pub fn faiss_IndexIVF_make_direct_map(
        index: *mut FaissIndexIVF,
        new_maintain_direct_map: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check the inverted lists' imbalance factor.\n\n 1= perfectly balanced, >1: imbalanced"]
    pub fn faiss_IndexIVF_imbalance_factor(index: *const FaissIndexIVF) -> f64;
}
extern "C" {
    #[doc = " display some stats about the inverted lists of the index"]
    pub fn faiss_IndexIVF_print_stats(index: *const FaissIndexIVF);
}
extern "C" {
    #[doc = " Get the IDs in an inverted list. IDs are written to `invlist`, which must be\n large enough\n to accommodate the full list.\n\n @param list_no the list ID\n @param invlist output pointer to a slice of memory, at least as long as the\n list's size\n @see faiss_IndexIVF_get_list_size(size_t)"]
    pub fn faiss_IndexIVF_invlists_get_ids(
        index: *const FaissIndexIVF,
        list_no: usize,
        invlist: *mut idx_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIndexIVFStats {
    pub nq: usize,
    pub nlist: usize,
    pub ndis: usize,
    pub nheap_updates: usize,
    pub quantization_time: f64,
    pub search_time: f64,
}
#[test]
fn bindgen_test_layout_FaissIndexIVFStats() {
    const UNINIT: ::std::mem::MaybeUninit<FaissIndexIVFStats> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FaissIndexIVFStats>(),
        48usize,
        concat!("Size of: ", stringify!(FaissIndexIVFStats))
    );
    assert_eq!(
        ::std::mem::align_of::<FaissIndexIVFStats>(),
        8usize,
        concat!("Alignment of ", stringify!(FaissIndexIVFStats))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissIndexIVFStats),
            "::",
            stringify!(nq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nlist) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissIndexIVFStats),
            "::",
            stringify!(nlist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ndis) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissIndexIVFStats),
            "::",
            stringify!(ndis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nheap_updates) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissIndexIVFStats),
            "::",
            stringify!(nheap_updates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quantization_time) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissIndexIVFStats),
            "::",
            stringify!(quantization_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).search_time) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissIndexIVFStats),
            "::",
            stringify!(search_time)
        )
    );
}
extern "C" {
    pub fn faiss_IndexIVFStats_reset(stats: *mut FaissIndexIVFStats);
}
extern "C" {
    #[doc = " global var that collects all statists"]
    pub fn faiss_get_indexIVF_stats() -> *mut FaissIndexIVFStats;
}
pub type FaissIndexIVFFlat = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexIVFFlat_free(obj: *mut FaissIndexIVFFlat);
}
extern "C" {
    pub fn faiss_IndexIVFFlat_cast(arg1: *mut FaissIndex) -> *mut FaissIndexIVFFlat;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_nlist(arg1: *const FaissIndexIVFFlat) -> usize;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_nprobe(arg1: *const FaissIndexIVFFlat) -> usize;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_set_nprobe(arg1: *mut FaissIndexIVFFlat, arg2: usize);
}
extern "C" {
    pub fn faiss_IndexIVFFlat_quantizer(arg1: *const FaissIndexIVFFlat) -> *mut FaissIndex;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_quantizer_trains_alone(
        arg1: *const FaissIndexIVFFlat,
    ) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_own_fields(arg1: *const FaissIndexIVFFlat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_set_own_fields(
        arg1: *mut FaissIndexIVFFlat,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " whether object owns the quantizer"]
    pub fn faiss_IndexIVFFlat_new(p_index: *mut *mut FaissIndexIVFFlat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_new_with(
        p_index: *mut *mut FaissIndexIVFFlat,
        quantizer: *mut FaissIndex,
        d: usize,
        nlist: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_new_with_metric(
        p_index: *mut *mut FaissIndexIVFFlat,
        quantizer: *mut FaissIndex,
        d: usize,
        nlist: usize,
        metric: FaissMetricType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_add_core(
        index: *mut FaissIndexIVFFlat,
        n: idx_t,
        x: *const f32,
        xids: *const idx_t,
        precomputed_idx: *const i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Update a subset of vectors.\n\n The index must have a direct_map\n\n @param nv     nb of vectors to update\n @param idx    vector indices to update, size nv\n @param v      vectors of new values, size nv*d"]
    pub fn faiss_IndexIVFFlat_update_vectors(
        index: *mut FaissIndexIVFFlat,
        nv: ::std::os::raw::c_int,
        idx: *mut idx_t,
        v: *const f32,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexLSH = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexLSH_free(obj: *mut FaissIndexLSH);
}
extern "C" {
    pub fn faiss_IndexLSH_cast(arg1: *mut FaissIndex) -> *mut FaissIndexLSH;
}
extern "C" {
    pub fn faiss_IndexLSH_nbits(arg1: *const FaissIndexLSH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexLSH_code_size(arg1: *const FaissIndexLSH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexLSH_rotate_data(arg1: *const FaissIndexLSH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexLSH_train_thresholds(arg1: *const FaissIndexLSH) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The sign of each vector component is put in a binary signature"]
    pub fn faiss_IndexLSH_new(
        p_index: *mut *mut FaissIndexLSH,
        d: idx_t,
        nbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexLSH_new_with_options(
        p_index: *mut *mut FaissIndexLSH,
        d: idx_t,
        nbits: ::std::os::raw::c_int,
        rotate_data: ::std::os::raw::c_int,
        train_thresholds: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissVectorTransform_H {
    _unused: [u8; 0],
}
pub type FaissVectorTransform = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_VectorTransform_free(obj: *mut FaissVectorTransform);
}
extern "C" {
    pub fn faiss_VectorTransform_is_trained(
        arg1: *const FaissVectorTransform,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_VectorTransform_d_in(arg1: *const FaissVectorTransform) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_VectorTransform_d_out(arg1: *const FaissVectorTransform) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform training on a representative set of vectors\n\n @param vt     opaque pointer to VectorTransform object\n @param n      nb of training vectors\n @param x      training vectors, size n * d"]
    pub fn faiss_VectorTransform_train(
        vt: *mut FaissVectorTransform,
        n: idx_t,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " apply the random rotation, return new allocated matrix\n @param     x size n * d_in\n @return    size n * d_out"]
    pub fn faiss_VectorTransform_apply(
        vt: *const FaissVectorTransform,
        n: idx_t,
        x: *const f32,
    ) -> *mut f32;
}
extern "C" {
    #[doc = " apply transformation and result is pre-allocated\n @param     x size n * d_in\n @param     xt size n * d_out"]
    pub fn faiss_VectorTransform_apply_noalloc(
        vt: *const FaissVectorTransform,
        n: idx_t,
        x: *const f32,
        xt: *mut f32,
    );
}
extern "C" {
    #[doc = " reverse transformation. May not be implemented or may return\n approximate result"]
    pub fn faiss_VectorTransform_reverse_transform(
        vt: *const FaissVectorTransform,
        n: idx_t,
        xt: *const f32,
        x: *mut f32,
    );
}
pub type FaissLinearTransform = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_LinearTransform_free(obj: *mut FaissLinearTransform);
}
extern "C" {
    #[doc = " compute x = A^T * (x - b)\n is reverse transform if A has orthonormal lines"]
    pub fn faiss_LinearTransform_transform_transpose(
        vt: *const FaissLinearTransform,
        n: idx_t,
        y: *const f32,
        x: *mut f32,
    );
}
extern "C" {
    #[doc = " compute A^T * A to set the is_orthonormal flag"]
    pub fn faiss_LinearTransform_set_is_orthonormal(vt: *mut FaissLinearTransform);
}
extern "C" {
    pub fn faiss_LinearTransform_have_bias(
        arg1: *const FaissLinearTransform,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_LinearTransform_is_orthonormal(
        arg1: *const FaissLinearTransform,
    ) -> ::std::os::raw::c_int;
}
pub type FaissRandomRotationMatrix = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_RandomRotationMatrix_free(obj: *mut FaissRandomRotationMatrix);
}
extern "C" {
    #[doc = " Getter for is_orthonormal"]
    pub fn faiss_RandomRotationMatrix_new_with(
        p_vt: *mut *mut FaissRandomRotationMatrix,
        d_in: ::std::os::raw::c_int,
        d_out: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type FaissPCAMatrix = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_PCAMatrix_free(obj: *mut FaissPCAMatrix);
}
extern "C" {
    pub fn faiss_PCAMatrix_new_with(
        p_vt: *mut *mut FaissPCAMatrix,
        d_in: ::std::os::raw::c_int,
        d_out: ::std::os::raw::c_int,
        eigen_power: f32,
        random_rotation: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_PCAMatrix_eigen_power(arg1: *const FaissPCAMatrix) -> f32;
}
extern "C" {
    pub fn faiss_PCAMatrix_random_rotation(arg1: *const FaissPCAMatrix) -> ::std::os::raw::c_int;
}
pub type FaissITQMatrix = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_ITQMatrix_free(obj: *mut FaissITQMatrix);
}
extern "C" {
    #[doc = " Getter for random_rotation"]
    pub fn faiss_ITQMatrix_new_with(
        p_vt: *mut *mut FaissITQMatrix,
        d: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type FaissITQTransform = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_ITQTransform_free(obj: *mut FaissITQTransform);
}
extern "C" {
    pub fn faiss_ITQTransform_new_with(
        p_vt: *mut *mut FaissITQTransform,
        d_in: ::std::os::raw::c_int,
        d_out: ::std::os::raw::c_int,
        do_pca: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_ITQTransform_do_pca(arg1: *const FaissITQTransform) -> ::std::os::raw::c_int;
}
pub type FaissOPQMatrix = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_OPQMatrix_free(obj: *mut FaissOPQMatrix);
}
extern "C" {
    #[doc = " Getter for do_pca"]
    pub fn faiss_OPQMatrix_new_with(
        p_vt: *mut *mut FaissOPQMatrix,
        d: ::std::os::raw::c_int,
        M: ::std::os::raw::c_int,
        d2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_OPQMatrix_verbose(arg1: *const FaissOPQMatrix) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_OPQMatrix_set_verbose(arg1: *mut FaissOPQMatrix, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn faiss_OPQMatrix_niter(arg1: *const FaissOPQMatrix) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_OPQMatrix_set_niter(arg1: *mut FaissOPQMatrix, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn faiss_OPQMatrix_niter_pq(arg1: *const FaissOPQMatrix) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_OPQMatrix_set_niter_pq(arg1: *mut FaissOPQMatrix, arg2: ::std::os::raw::c_int);
}
pub type FaissRemapDimensionsTransform = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_RemapDimensionsTransform_free(obj: *mut FaissRemapDimensionsTransform);
}
extern "C" {
    pub fn faiss_RemapDimensionsTransform_new_with(
        p_vt: *mut *mut FaissRemapDimensionsTransform,
        d_in: ::std::os::raw::c_int,
        d_out: ::std::os::raw::c_int,
        uniform: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type FaissNormalizationTransform = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_NormalizationTransform_free(obj: *mut FaissNormalizationTransform);
}
extern "C" {
    pub fn faiss_NormalizationTransform_new_with(
        p_vt: *mut *mut FaissNormalizationTransform,
        d: ::std::os::raw::c_int,
        norm: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_NormalizationTransform_norm(arg1: *const FaissNormalizationTransform) -> f32;
}
pub type FaissCenteringTransform = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_CenteringTransform_free(obj: *mut FaissCenteringTransform);
}
extern "C" {
    pub fn faiss_CenteringTransform_new_with(
        p_vt: *mut *mut FaissCenteringTransform,
        d: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexPreTransform = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexPreTransform_free(obj: *mut FaissIndexPreTransform);
}
extern "C" {
    pub fn faiss_IndexPreTransform_cast(arg1: *mut FaissIndex) -> *mut FaissIndexPreTransform;
}
extern "C" {
    pub fn faiss_IndexPreTransform_index(arg1: *const FaissIndexPreTransform) -> *mut FaissIndex;
}
extern "C" {
    pub fn faiss_IndexPreTransform_own_fields(
        arg1: *const FaissIndexPreTransform,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexPreTransform_set_own_fields(
        arg1: *mut FaissIndexPreTransform,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Index that applies a LinearTransform transform on vectors before\n  handing them over to a sub-index"]
    pub fn faiss_IndexPreTransform_new(
        p_index: *mut *mut FaissIndexPreTransform,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexPreTransform_new_with(
        p_index: *mut *mut FaissIndexPreTransform,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexPreTransform_new_with_transform(
        p_index: *mut *mut FaissIndexPreTransform,
        ltrans: *mut FaissVectorTransform,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexPreTransform_prepend_transform(
        index: *mut FaissIndexPreTransform,
        ltrans: *mut FaissVectorTransform,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexReplicas = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexReplicas_free(obj: *mut FaissIndexReplicas);
}
extern "C" {
    pub fn faiss_IndexReplicas_own_fields(arg1: *const FaissIndexReplicas)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexReplicas_set_own_fields(
        arg1: *mut FaissIndexReplicas,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Index that concatenates the results from several sub-indexes"]
    pub fn faiss_IndexReplicas_new(
        p_index: *mut *mut FaissIndexReplicas,
        d: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexReplicas_new_with_options(
        p_index: *mut *mut FaissIndexReplicas,
        d: idx_t,
        threaded: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexReplicas_add_replica(
        index: *mut FaissIndexReplicas,
        replica: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexReplicas_remove_replica(
        index: *mut FaissIndexReplicas,
        replica: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexReplicas_at(
        index: *mut FaissIndexReplicas,
        i: ::std::os::raw::c_int,
    ) -> *mut FaissIndex;
}
#[doc = "< 8 bits per component"]
pub const FaissQuantizerType_QT_8bit: FaissQuantizerType = 0;
#[doc = "< 4 bits per component"]
pub const FaissQuantizerType_QT_4bit: FaissQuantizerType = 1;
#[doc = "< same, shared range for all dimensions"]
pub const FaissQuantizerType_QT_8bit_uniform: FaissQuantizerType = 2;
pub const FaissQuantizerType_QT_4bit_uniform: FaissQuantizerType = 3;
pub const FaissQuantizerType_QT_fp16: FaissQuantizerType = 4;
#[doc = "< fast indexing of uint8s"]
pub const FaissQuantizerType_QT_8bit_direct: FaissQuantizerType = 5;
#[doc = "< 6 bits per component"]
pub const FaissQuantizerType_QT_6bit: FaissQuantizerType = 6;
pub type FaissQuantizerType = ::std::os::raw::c_uint;
pub type FaissIndexScalarQuantizer = FaissIndex_H;
extern "C" {
    #[doc = " Opaque type for IndexScalarQuantizer"]
    pub fn faiss_IndexScalarQuantizer_new(
        p_index: *mut *mut FaissIndexScalarQuantizer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexScalarQuantizer_new_with(
        p_index: *mut *mut FaissIndexScalarQuantizer,
        d: idx_t,
        qt: FaissQuantizerType,
        metric: FaissMetricType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexScalarQuantizer_cast(arg1: *mut FaissIndex)
        -> *mut FaissIndexScalarQuantizer;
}
extern "C" {
    pub fn faiss_IndexScalarQuantizer_free(obj: *mut FaissIndexScalarQuantizer);
}
pub type FaissIndexIVFScalarQuantizer = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_cast(
        arg1: *mut FaissIndex,
    ) -> *mut FaissIndexIVFScalarQuantizer;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_free(obj: *mut FaissIndexIVFScalarQuantizer);
}
extern "C" {
    #[doc = " Opaque type for IndexIVFScalarQuantizer"]
    pub fn faiss_IndexIVFScalarQuantizer_new(
        p_index: *mut *mut FaissIndexIVFScalarQuantizer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_new_with(
        p_index: *mut *mut FaissIndexIVFScalarQuantizer,
        quantizer: *mut FaissIndex,
        d: idx_t,
        nlist: usize,
        qt: FaissQuantizerType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_new_with_metric(
        p_index: *mut *mut FaissIndexIVFScalarQuantizer,
        quantizer: *mut FaissIndex,
        d: usize,
        nlist: usize,
        qt: FaissQuantizerType,
        metric: FaissMetricType,
        encode_residual: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_nlist(arg1: *const FaissIndexIVFScalarQuantizer) -> usize;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_nprobe(arg1: *const FaissIndexIVFScalarQuantizer)
        -> usize;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_set_nprobe(
        arg1: *mut FaissIndexIVFScalarQuantizer,
        arg2: usize,
    );
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_quantizer(
        arg1: *const FaissIndexIVFScalarQuantizer,
    ) -> *mut FaissIndex;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_own_fields(
        arg1: *const FaissIndexIVFScalarQuantizer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_set_own_fields(
        arg1: *mut FaissIndexIVFScalarQuantizer,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " whether object owns the quantizer"]
    pub fn faiss_IndexIVFScalarQuantizer_add_core(
        index: *mut FaissIndexIVFScalarQuantizer,
        n: idx_t,
        x: *const f32,
        xids: *const idx_t,
        precomputed_idx: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_train_residual(
        index: *mut FaissIndexIVFScalarQuantizer,
        n: idx_t,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexShards = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexShards_free(obj: *mut FaissIndexShards);
}
extern "C" {
    pub fn faiss_IndexShards_own_fields(arg1: *const FaissIndexShards) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_set_own_fields(
        arg1: *mut FaissIndexShards,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn faiss_IndexShards_successive_ids(arg1: *const FaissIndexShards)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_set_successive_ids(
        arg1: *mut FaissIndexShards,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Index that concatenates the results from several sub-indexes"]
    pub fn faiss_IndexShards_new(
        p_index: *mut *mut FaissIndexShards,
        d: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_new_with_options(
        p_index: *mut *mut FaissIndexShards,
        d: idx_t,
        threaded: ::std::os::raw::c_int,
        successive_ids: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_add_shard(
        index: *mut FaissIndexShards,
        shard: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_remove_shard(
        index: *mut FaissIndexShards,
        shard: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_at(
        index: *mut FaissIndexShards,
        i: ::std::os::raw::c_int,
    ) -> *mut FaissIndex;
}
pub type FaissIndexIDMap = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexIDMap_own_fields(arg1: *const FaissIndexIDMap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIDMap_set_own_fields(arg1: *mut FaissIndexIDMap, arg2: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Index that translates search results to ids"]
    pub fn faiss_IndexIDMap_new(
        p_index: *mut *mut FaissIndexIDMap,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIDMap_cast(arg1: *mut FaissIndex) -> *mut FaissIndexIDMap;
}
extern "C" {
    #[doc = " get a pointer to the index map's internal ID vector (the `id_map` field).\n The outputs of this function become invalid after any operation that can\n modify the index.\n\n @param index   opaque pointer to index object\n @param p_id_map    output, the pointer to the beginning of `id_map`.\n @param p_size  output, the current length of `id_map`."]
    pub fn faiss_IndexIDMap_id_map(
        index: *mut FaissIndexIDMap,
        p_id_map: *mut *mut idx_t,
        p_size: *mut usize,
    );
}
extern "C" {
    #[doc = " get a pointer to the sub-index (the `index` field).\n The outputs of this function become invalid after any operation that can\n modify the index.\n\n @param index   opaque pointer to index object"]
    pub fn faiss_IndexIDMap_sub_index(index: *mut FaissIndexIDMap) -> *mut FaissIndex;
}
pub type FaissIndexIDMap2 = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexIDMap2_own_fields(arg1: *const FaissIndexIDMap2) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIDMap2_set_own_fields(
        arg1: *mut FaissIndexIDMap2,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " same as IndexIDMap but also provides an efficient reconstruction\nimplementation via a 2-way index"]
    pub fn faiss_IndexIDMap2_new(
        p_index: *mut *mut FaissIndexIDMap2,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " make the rev_map from scratch"]
    pub fn faiss_IndexIDMap2_construct_rev_map(
        index: *mut FaissIndexIDMap2,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIDMap2_cast(arg1: *mut FaissIndex) -> *mut FaissIndexIDMap2;
}
extern "C" {
    #[doc = " get a pointer to the index map's internal ID vector (the `id_map` field).\n The outputs of this function become invalid after any operation that can\n modify the index.\n\n @param index   opaque pointer to index object\n @param p_id_map    output, the pointer to the beginning of `id_map`.\n @param p_size  output, the current length of `id_map`."]
    pub fn faiss_IndexIDMap2_id_map(
        index: *mut FaissIndexIDMap2,
        p_id_map: *mut *mut idx_t,
        p_size: *mut usize,
    );
}
extern "C" {
    #[doc = " get a pointer to the sub-index (the `index` field).\n The outputs of this function become invalid after any operation that can\n modify the index.\n\n @param index   opaque pointer to index object"]
    pub fn faiss_IndexIDMap2_sub_index(index: *mut FaissIndexIDMap2) -> *mut FaissIndex;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compute pairwise distances between sets of vectors"]
    pub fn faiss_pairwise_L2sqr(
        d: i64,
        nq: i64,
        xq: *const f32,
        nb: i64,
        xb: *const f32,
        dis: *mut f32,
        ldq: i64,
        ldb: i64,
        ldd: i64,
    );
}
extern "C" {
    #[doc = " Compute pairwise distances between sets of vectors\n arguments from \"faiss_pairwise_L2sqr\"\n ldq equal -1 by default\n ldb equal -1 by default\n ldd equal -1 by default"]
    pub fn faiss_pairwise_L2sqr_with_defaults(
        d: i64,
        nq: i64,
        xq: *const f32,
        nb: i64,
        xb: *const f32,
        dis: *mut f32,
    );
}
extern "C" {
    #[doc = " compute the inner product between nx vectors x and one y"]
    pub fn faiss_fvec_inner_products_ny(
        ip: *mut f32,
        x: *const f32,
        y: *const f32,
        d: usize,
        ny: usize,
    );
}
extern "C" {
    #[doc = " compute ny square L2 distance between x and a set of contiguous y vectors"]
    pub fn faiss_fvec_L2sqr_ny(dis: *mut f32, x: *const f32, y: *const f32, d: usize, ny: usize);
}
extern "C" {
    #[doc = " squared norm of a vector"]
    pub fn faiss_fvec_norm_L2sqr(x: *const f32, d: usize) -> f32;
}
extern "C" {
    #[doc = " compute the L2 norms for a set of vectors"]
    pub fn faiss_fvec_norms_L2(norms: *mut f32, x: *const f32, d: usize, nx: usize);
}
extern "C" {
    #[doc = " same as fvec_norms_L2, but computes squared norms"]
    pub fn faiss_fvec_norms_L2sqr(norms: *mut f32, x: *const f32, d: usize, nx: usize);
}
extern "C" {
    #[doc = " L2-renormalize a set of vector. Nothing done if the vector is 0-normed"]
    pub fn faiss_fvec_renorm_L2(d: usize, nx: usize, x: *mut f32);
}
extern "C" {
    #[doc = " Setter of threshold value on nx above which we switch to BLAS to compute\n distances"]
    pub fn faiss_set_distance_compute_blas_threshold(value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Getter of threshold value on nx above which we switch to BLAS to compute\n distances"]
    pub fn faiss_get_distance_compute_blas_threshold() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Setter of block sizes value for BLAS distance computations"]
    pub fn faiss_set_distance_compute_blas_query_bs(value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Getter of block sizes value for BLAS distance computations"]
    pub fn faiss_get_distance_compute_blas_query_bs() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Setter of block sizes value for BLAS distance computations"]
    pub fn faiss_set_distance_compute_blas_database_bs(value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Getter of block sizes value for BLAS distance computations"]
    pub fn faiss_get_distance_compute_blas_database_bs() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Setter of number of results we switch to a reservoir to collect results\n rather than a heap"]
    pub fn faiss_set_distance_compute_min_k_reservoir(value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Getter of number of results we switch to a reservoir to collect results\n rather than a heap"]
    pub fn faiss_get_distance_compute_min_k_reservoir() -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
